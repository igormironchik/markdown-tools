<Comment># Original: https://learnxinyminutes.com/docs/elixir/</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Single line comments start with a number symbol.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There's no multi-line comment,</Comment><br/>
<Comment># but you can stack multiple comments.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To use the elixir shell use the `iex` command.</Comment><br/>
<Comment># Compile your modules with the `elixirc` command.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Both should be in your path if you installed elixir correctly.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Basic types</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are numbers</Comment><br/>
<Integer>3</Integer><Normal Text>    </Normal Text><Comment># integer</Comment><br/>
<Hex>0x1F</Hex><Normal Text> </Normal Text><Comment># integer</Comment><br/>
<Float>3.0</Float><Normal Text>  </Normal Text><Comment># float</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Atoms, that are literals, a constant with name. They start with `:`.</Comment><br/>
<Atom>:hello</Atom><Normal Text> </Normal Text><Comment># atom</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Tuples that are stored contiguously in memory.</Comment><br/>
<Braces>{</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>}</Braces><Normal Text> </Normal Text><Comment># tuple</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can access a tuple element with the `elem` function:</Comment><br/>
<Function>elem</Function><Braces>({</Braces><Integer>1</Integer><Normal Text>, </Normal Text><Integer>2</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>}</Braces><Normal Text>, </Normal Text><Integer>0</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Lists that are implemented as linked lists.</Comment><br/>
<Braces>[</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>]</Braces><Normal Text> </Normal Text><Comment># list</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can access the head and tail of a list as follows:</Comment><br/>
<Braces>[</Braces><Variable>head</Variable><Normal Text> </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Variable>tail</Variable><Braces>]</Braces><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Braces>[</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>]</Braces><br/>
<Variable>head</Variable><Normal Text> </Normal Text><Comment>#=> 1</Comment><br/>
<Variable>tail</Variable><Normal Text> </Normal Text><Comment>#=> [2,3]</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># In elixir, just like in Erlang, the `=` denotes pattern matching and</Comment><br/>
<Comment># not an assignment.</Comment><br/>
<Comment>#</Comment><br/>
<Comment># This means that the left-hand side (pattern) is matched against a</Comment><br/>
<Comment># right-hand side.</Comment><br/>
<Comment>#</Comment><br/>
<Comment># This is how the above example of accessing the head and tail of a list works.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># A pattern match will error when the sides don't match, in this example</Comment><br/>
<Comment># the tuples have different sizes.</Comment><br/>
<Comment># {a, b, c} = {1, 2} #=> ** (MatchError) no match of right hand side value: {1,2}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are also binaries</Comment><br/>
<Braces><<</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>>></Braces><Normal Text> </Normal Text><Comment># binary</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings and char lists</Comment><br/>
<String>"hello"</String><Normal Text> </Normal Text><Comment># string</Comment><br/>
<Charlist>'hello'</Charlist><Normal Text> </Normal Text><Comment># char list</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Multi-line strings</Comment><br/>
<String>"""</String><br/>
<String>I'm a multi-line</String><br/>
<String>string.</String><br/>
<String>"""</String><br/>
<Comment>#=> "I'm a multi-line\nstring.\n"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings are all encoded in UTF-8:</Comment><br/>
<String>"héllò"</String><Normal Text> </Normal Text><Comment>#=> "héllò"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Strings are really just binaries, and char lists are just lists.</Comment><br/>
<Braces><<</Braces><Char Literal>?a</Char Literal><Normal Text>, </Normal Text><Char Literal>?b</Char Literal><Normal Text>, </Normal Text><Char Literal>?c</Char Literal><Braces>>></Braces><Normal Text> </Normal Text><Comment>#=> "abc"</Comment><br/>
<Braces>[</Braces><Char Literal>?a</Char Literal><Normal Text>, </Normal Text><Char Literal>?b</Char Literal><Normal Text>, </Normal Text><Char Literal>?c</Char Literal><Braces>]</Braces><Normal Text>   </Normal Text><Comment>#=> 'abc'</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `?a` in elixir returns the ASCII integer for the letter `a`</Comment><br/>
<Char Literal>?a</Char Literal><Normal Text> </Normal Text><Comment>#=> 97</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To concatenate lists use `++`, for binaries use `<>`</Comment><br/>
<Braces>[</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>]</Braces><Normal Text> </Normal Text><Operator>++</Operator><Normal Text> </Normal Text><Braces>[</Braces><Integer>4</Integer><Normal Text>,</Normal Text><Integer>5</Integer><Braces>]</Braces><Normal Text>     </Normal Text><Comment>#=> [1,2,3,4,5]</Comment><br/>
<Charlist>'hello '</Charlist><Normal Text> </Normal Text><Operator>++</Operator><Normal Text> </Normal Text><Charlist>'world'</Charlist><Normal Text>  </Normal Text><Comment>#=> 'hello world'</Comment><br/>
<Normal Text></Normal Text><br/>
<Braces><<</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>>></Braces><Normal Text> </Normal Text><Operator><></Operator><Normal Text> </Normal Text><Braces><<</Braces><Integer>4</Integer><Normal Text>,</Normal Text><Integer>5</Integer><Braces>>></Braces><Normal Text> </Normal Text><Comment>#=> <<1,2,3,4,5>></Comment><br/>
<String>"hello "</String><Normal Text> </Normal Text><Operator><></Operator><Normal Text> </Normal Text><String>"world"</String><Normal Text>  </Normal Text><Comment>#=> "hello world"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Ranges are represented as `start..end` (both inclusive)</Comment><br/>
<Integer>1</Integer><Operator>..</Operator><Integer>10</Integer><Normal Text> </Normal Text><Comment>#=> 1..10</Comment><br/>
<Variable>lower</Variable><Operator>..</Operator><Variable>upper</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Integer>1</Integer><Operator>..</Operator><Integer>10</Integer><Normal Text> </Normal Text><Comment># Can use pattern matching on ranges as well</Comment><br/>
<Braces>[</Braces><Variable>lower</Variable><Normal Text>, </Normal Text><Variable>upper</Variable><Braces>]</Braces><Normal Text> </Normal Text><Comment>#=> [1, 10]</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Operators</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Some math</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text>  </Normal Text><Comment>#=> 2</Comment><br/>
<Integer>10</Integer><Normal Text> </Normal Text><Operator>-</Operator><Normal Text> </Normal Text><Integer>5</Integer><Normal Text> </Normal Text><Comment>#=> 5</Comment><br/>
<Integer>5</Integer><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text>  </Normal Text><Comment>#=> 10</Comment><br/>
<Integer>10</Integer><Normal Text> </Normal Text><Operator>/</Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Comment>#=> 5.0</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># In elixir the operator `/` always returns a float.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To do integer division use `div`</Comment><br/>
<Function>div</Function><Braces>(</Braces><Integer>10</Integer><Normal Text>, </Normal Text><Integer>2</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 5</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To get the division remainder use `rem`</Comment><br/>
<Function>rem</Function><Braces>(</Braces><Integer>10</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># There are also boolean operators: `or`, `and` and `not`.</Comment><br/>
<Comment># These operators expect a boolean as their first argument.</Comment><br/>
<Atom>true</Atom><Normal Text> </Normal Text><Keyword>and</Keyword><Normal Text> </Normal Text><Atom>true</Atom><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Atom>false</Atom><Normal Text> </Normal Text><Keyword>or</Keyword><Normal Text> </Normal Text><Atom>true</Atom><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Comment># 1 and true    #=> ** (ArgumentError) argument error</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir also provides `||`, `&&` and `!` which accept arguments of any type.</Comment><br/>
<Comment># All values except `false` and `nil` will evaluate to true.</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>||</Operator><Normal Text> </Normal Text><Atom>true</Atom><Normal Text>  </Normal Text><Comment>#=> 1</Comment><br/>
<Atom>false</Atom><Normal Text> </Normal Text><Operator>&&</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Atom>nil</Atom><Normal Text> </Normal Text><Operator>&&</Operator><Normal Text> </Normal Text><Integer>20</Integer><Normal Text>  </Normal Text><Comment>#=> nil</Comment><br/>
<Operator>!</Operator><Variable>true</Variable><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># For comparisons we have: `==`, `!=`, `===`, `!==`, `<=`, `>=`, `<` and `>`</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>!=</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator><</Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text>  </Normal Text><Comment>#=> true</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `===` and `!==` are more strict when comparing integers and floats:</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Float>1.0</Float><Normal Text>  </Normal Text><Comment>#=> true</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator>===</Operator><Normal Text> </Normal Text><Float>1.0</Float><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># We can also compare two different data types:</Comment><br/>
<Integer>1</Integer><Normal Text> </Normal Text><Operator><</Operator><Normal Text> </Normal Text><Atom>:hello</Atom><Normal Text> </Normal Text><Comment>#=> true</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The overall sorting order is defined below:</Comment><br/>
<Comment># number < atom < reference < functions < port < pid < tuple < list < bit string</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To quote Joe Armstrong on this: "The actual order is not important,</Comment><br/>
<Comment># but that a total ordering is well defined is important."</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Control Flow</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `if` expression</Comment><br/>
<Control Flow>if</Control Flow><Normal Text> </Normal Text><Atom>false</Atom><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><String>"This will never be seen"</String><br/>
<Control Flow>else</Control Flow><br/>
<Normal Text>  </Normal Text><String>"This will"</String><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># There's also `unless`</Comment><br/>
<Control Flow>unless</Control Flow><Normal Text> </Normal Text><Atom>true</Atom><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><String>"This will never be seen"</String><br/>
<Control Flow>else</Control Flow><br/>
<Normal Text>  </Normal Text><String>"This will"</String><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># Remember pattern matching? Many control-flow structures in elixir rely on it.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `case` allows us to compare a value against many patterns:</Comment><br/>
<Keyword>case</Keyword><Normal Text> </Normal Text><Braces>{</Braces><Atom>:one</Atom><Normal Text>, </Normal Text><Atom>:two</Atom><Braces>}</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Braces>{</Braces><Atom>:four</Atom><Normal Text>, </Normal Text><Atom>:five</Atom><Braces>}</Braces><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This won't match"</String><br/>
<Normal Text>  </Normal Text><Braces>{</Braces><Atom>:one</Atom><Normal Text>, </Normal Text><Variable>x</Variable><Braces>}</Braces><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This will match and bind `x` to `:two`"</String><br/>
<Normal Text>  </Normal Text><Variable Underscore>_</Variable Underscore><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"This will match any value"</String><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># It's common to bind the value to `_` if we don't need it.</Comment><br/>
<Comment># For example, if only the head of a list matters to us:</Comment><br/>
<Braces>[</Braces><Variable>head</Variable><Normal Text> </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Variable Underscore>_</Variable Underscore><Braces>]</Braces><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Braces>[</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>]</Braces><br/>
<Variable>head</Variable><Normal Text> </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># For better readability we can do the following:</Comment><br/>
<Braces>[</Braces><Variable>head</Variable><Normal Text> </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Variable Underscore>_tail</Variable Underscore><Braces>]</Braces><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Braces>[</Braces><Atom>:a</Atom><Normal Text>, </Normal Text><Atom>:b</Atom><Normal Text>, </Normal Text><Atom>:c</Atom><Braces>]</Braces><br/>
<Variable>head</Variable><Normal Text> </Normal Text><Comment>#=> :a</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `cond` lets us check for many conditions at the same time.</Comment><br/>
<Comment># Use `cond` instead of nesting many `if` expressions.</Comment><br/>
<Control Flow>cond</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>3</Integer><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"I will never be seen"</String><br/>
<Normal Text>  </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Integer>5</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>12</Integer><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"Me neither"</String><br/>
<Normal Text>  </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>3</Integer><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"But I will"</String><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># It is common to set the last condition equal to `true`, which will always match.</Comment><br/>
<Control Flow>cond</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Integer>1</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>3</Integer><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"I will never be seen"</String><br/>
<Normal Text>  </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Integer>5</Integer><Normal Text> </Normal Text><Operator>==</Operator><Normal Text> </Normal Text><Integer>12</Integer><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"Me neither"</String><br/>
<Normal Text>  </Normal Text><Atom>true</Atom><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><String>"But I will (this is essentially an else)"</String><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># `try/catch` is used to catch values that are thrown, it also supports an</Comment><br/>
<Comment># `after` clause that is invoked whether or not a value is caught.</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>throw</Control Flow><Braces>(</Braces><Atom>:hello</Atom><Braces>)</Braces><br/>
<Control Flow>catch</Control Flow><br/>
<Normal Text>  </Normal Text><Variable>message</Variable><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"Got </String><Interpolation>#{</Interpolation><Variable>message</Variable><Interpolation>}</Interpolation><String>."</String><br/>
<Keyword>after</Keyword><br/>
<Normal Text>  </Normal Text><Module>IO</Module><Normal Text>.</Normal Text><Function>puts</Function><Braces>(</Braces><String>"I'm the after clause."</String><Braces>)</Braces><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> I'm the after clause</Comment><br/>
<Comment># "Got :hello"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Modules and Functions</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Anonymous functions (notice the dot)</Comment><br/>
<Variable>square</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Function>fn</Function><Braces>(</Braces><Variable>x</Variable><Braces>)</Braces><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Keyword>end</Keyword><br/>
<Variable>square</Variable><Normal Text>.</Normal Text><Braces>(</Braces><Integer>5</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 25</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># They also accept many clauses and guards.</Comment><br/>
<Comment># Guards let you fine tune pattern matching,</Comment><br/>
<Comment># they are indicated by the `when` keyword:</Comment><br/>
<Variable>f</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Keyword>fn</Keyword><br/>
<Normal Text>  </Normal Text><Variable>x</Variable><Normal Text>, </Normal Text><Variable>y</Variable><Normal Text> </Normal Text><Keyword>when</Keyword><Normal Text> </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Operator>></Operator><Normal Text> </Normal Text><Integer>0</Integer><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Variable>y</Variable><br/>
<Normal Text>  </Normal Text><Variable>x</Variable><Normal Text>, </Normal Text><Variable>y</Variable><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>y</Variable><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Variable>f</Variable><Normal Text>.</Normal Text><Braces>(</Braces><Integer>1</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>)</Braces><Normal Text>  </Normal Text><Comment>#=> 4</Comment><br/>
<Variable>f</Variable><Normal Text>.</Normal Text><Braces>(</Braces><Operator>-</Operator><Integer>1</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> -3</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir also provides many built-in functions.</Comment><br/>
<Comment># These are available in the current scope.</Comment><br/>
<Function>is_number</Function><Braces>(</Braces><Integer>10</Integer><Braces>)</Braces><Normal Text>    </Normal Text><Comment>#=> true</Comment><br/>
<Function>is_list</Function><Braces>(</Braces><String>"hello"</String><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> false</Comment><br/>
<Function>elem</Function><Braces>({</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>}</Braces><Normal Text>, </Normal Text><Integer>0</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># You can group several functions into a module. Inside a module use `def`</Comment><br/>
<Comment># to define your functions.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>Math</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>sum</Function><Braces>(</Braces><Variable>a</Variable><Normal Text>, </Normal Text><Variable>b</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Variable>a</Variable><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Variable>b</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>square</Function><Braces>(</Braces><Variable>x</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>x</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Module>Math</Module><Normal Text>.</Normal Text><Function>sum</Function><Braces>(</Braces><Integer>1</Integer><Normal Text>, </Normal Text><Integer>2</Integer><Braces>)</Braces><Normal Text>  </Normal Text><Comment>#=> 3</Comment><br/>
<Module>Math</Module><Normal Text>.</Normal Text><Function>square</Function><Braces>(</Braces><Integer>3</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 9</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To compile our simple Math module save it as `math.ex` and use `elixirc`</Comment><br/>
<Comment># in your terminal: elixirc math.ex</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Inside a module we can define functions with `def` and private functions with `defp`.</Comment><br/>
<Comment># A function defined with `def` is available to be invoked from other modules,</Comment><br/>
<Comment># a private function can only be invoked locally.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>PrivateMath</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>sum</Function><Braces>(</Braces><Variable>a</Variable><Normal Text>, </Normal Text><Variable>b</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Function>do_sum</Function><Braces>(</Braces><Variable>a</Variable><Normal Text>, </Normal Text><Variable>b</Variable><Braces>)</Braces><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Normal Text>  </Normal Text><Definition>defp</Definition><Normal Text> </Normal Text><Function>do_sum</Function><Braces>(</Braces><Variable>a</Variable><Normal Text>, </Normal Text><Variable>b</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Variable>a</Variable><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Variable>b</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Module>PrivateMath</Module><Normal Text>.</Normal Text><Function>sum</Function><Braces>(</Braces><Integer>1</Integer><Normal Text>, </Normal Text><Integer>2</Integer><Braces>)</Braces><Normal Text>    </Normal Text><Comment>#=> 3</Comment><br/>
<Comment># PrivateMath.do_sum(1, 2) #=> ** (UndefinedFunctionError)</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Function declarations also support guards and multiple clauses:</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>Geometry</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>area</Function><Braces>({</Braces><Atom>:rectangle</Atom><Normal Text>, </Normal Text><Variable>w</Variable><Normal Text>, </Normal Text><Variable>h</Variable><Braces>})</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Variable>w</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>h</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>area</Function><Braces>({</Braces><Atom>:circle</Atom><Normal Text>, </Normal Text><Variable>r</Variable><Braces>})</Braces><Normal Text> </Normal Text><Keyword>when</Keyword><Normal Text> </Normal Text><Function>is_number</Function><Braces>(</Braces><Variable>r</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Float>3.14</Float><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>r</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>r</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Module>Geometry</Module><Normal Text>.</Normal Text><Function>area</Function><Braces>({</Braces><Atom>:rectangle</Atom><Normal Text>, </Normal Text><Integer>2</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>})</Braces><Normal Text> </Normal Text><Comment>#=> 6</Comment><br/>
<Module>Geometry</Module><Normal Text>.</Normal Text><Function>area</Function><Braces>({</Braces><Atom>:circle</Atom><Normal Text>, </Normal Text><Integer>3</Integer><Braces>})</Braces><Normal Text>       </Normal Text><Comment>#=> 28.25999999999999801048</Comment><br/>
<Comment># Geometry.area({:circle, "not_a_number"})</Comment><br/>
<Comment>#=> ** (FunctionClauseError) no function clause matching in Geometry.area/1</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Due to immutability, recursion is a big part of elixir</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>Recursion</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>sum_list</Function><Braces>([</Braces><Variable>head</Variable><Normal Text> </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Variable>tail</Variable><Braces>]</Braces><Normal Text>, </Normal Text><Variable>acc</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Function>sum_list</Function><Braces>(</Braces><Variable>tail</Variable><Normal Text>, </Normal Text><Variable>acc</Variable><Normal Text> </Normal Text><Operator>+</Operator><Normal Text> </Normal Text><Variable>head</Variable><Braces>)</Braces><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>sum_list</Function><Braces>([]</Braces><Normal Text>, </Normal Text><Variable>acc</Variable><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Variable>acc</Variable><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Module>Recursion</Module><Normal Text>.</Normal Text><Function>sum_list</Function><Braces>([</Braces><Integer>1</Integer><Normal Text>,</Normal Text><Integer>2</Integer><Normal Text>,</Normal Text><Integer>3</Integer><Braces>]</Braces><Normal Text>, </Normal Text><Integer>0</Integer><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 6</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir modules support attributes, there are built-in attributes and you</Comment><br/>
<Comment># may also add custom ones.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>MyMod</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><DocComment>@moduledoc """</DocComment><br/>
<DocComment>  This is a built-in attribute on a example module.</DocComment><br/>
<DocComment>  """</DocComment><br/>
<Normal Text></Normal Text><br/>
<Normal Text>  @my_data </Normal Text><Integer>100</Integer><Normal Text> </Normal Text><Comment># This is a custom attribute.</Comment><br/>
<Normal Text>  </Normal Text><Module>IO</Module><Normal Text>.</Normal Text><Function>inspect</Function><Braces>(</Braces><Normal Text>@my_data</Normal Text><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> 100</Comment><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Structs and Exceptions</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Structs are extensions on top of maps that bring default values,</Comment><br/>
<Comment># compile-time guarantees and polymorphism into Elixir.</Comment><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>Person</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>defstruct</Definition><Normal Text> </Normal Text><Atom>name:</Atom><Normal Text> </Normal Text><Atom>nil</Atom><Normal Text>, </Normal Text><Atom>age:</Atom><Normal Text> </Normal Text><Integer>0</Integer><Normal Text>, </Normal Text><Atom>height:</Atom><Normal Text> </Normal Text><Integer>0</Integer><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Variable>joe_info</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Braces>%</Braces><Module>Person</Module><Braces>{</Braces><Normal Text> </Normal Text><Atom>name:</Atom><Normal Text> </Normal Text><String>"Joe"</String><Normal Text>, </Normal Text><Atom>age:</Atom><Normal Text> </Normal Text><Integer>30</Integer><Normal Text>, </Normal Text><Atom>height:</Atom><Normal Text> </Normal Text><Integer>180</Integer><Normal Text> </Normal Text><Braces>}</Braces><br/>
<Comment>#=> %Person{age: 30, height: 180, name: "Joe"}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Access the value of name</Comment><br/>
<Variable>joe_info</Variable><Normal Text>.</Normal Text><Variable>name</Variable><Normal Text> </Normal Text><Comment>#=> "Joe"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Update the value of age</Comment><br/>
<Variable>older_joe_info</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Braces>%{</Braces><Normal Text> </Normal Text><Variable>joe_info</Variable><Normal Text> </Normal Text><Operator>|</Operator><Normal Text> </Normal Text><Atom>age:</Atom><Normal Text> </Normal Text><Integer>31</Integer><Normal Text> </Normal Text><Braces>}</Braces><br/>
<Comment>#=> %Person{age: 31, height: 180, name: "Joe"}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The `try` block with the `rescue` keyword is used to handle exceptions</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>raise</Control Flow><Normal Text> </Normal Text><String>"some error"</String><br/>
<Control Flow>rescue</Control Flow><br/>
<Normal Text>  </Normal Text><Module>RuntimeError</Module><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"rescued a runtime error"</String><br/>
<Normal Text>  </Normal Text><Variable Underscore>_error</Variable Underscore><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><String>"this will rescue any error"</String><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> "rescued a runtime error"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># All exceptions have a message</Comment><br/>
<Control Flow>try</Control Flow><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Control Flow>raise</Control Flow><Normal Text> </Normal Text><String>"some error"</String><br/>
<Control Flow>rescue</Control Flow><br/>
<Normal Text>  </Normal Text><Variable>x</Variable><Normal Text> </Normal Text><Keyword>in</Keyword><Normal Text> </Normal Text><Braces>[</Braces><Module>RuntimeError</Module><Braces>]</Braces><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>    </Normal Text><Variable>x</Variable><Normal Text>.</Normal Text><Variable>message</Variable><br/>
<Keyword>end</Keyword><br/>
<Comment>#=> "some error"</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment>## ---------------------------</Comment><br/>
<Comment>## -- Concurrency</Comment><br/>
<Comment>## ---------------------------</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Elixir relies on the actor model for concurrency. All we need to write</Comment><br/>
<Comment># concurrent programs in elixir are three primitives: spawning processes,</Comment><br/>
<Comment># sending messages and receiving messages.</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># To start a new process we use the `spawn` function, which takes a function</Comment><br/>
<Comment># as argument.</Comment><br/>
<Variable>f</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Keyword>fn</Keyword><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Integer>2</Integer><Normal Text> </Normal Text><Keyword>end</Keyword><Normal Text> </Normal Text><Comment>#=> #Function<erl_eval.20.80484245></Comment><br/>
<Function>spawn</Function><Braces>(</Braces><Variable>f</Variable><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> #PID<0.40.0></Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># `spawn` returns a pid (process identifier), you can use this pid to send</Comment><br/>
<Comment># messages to the process. To do message passing we use the `send` operator.</Comment><br/>
<Comment># For all of this to be useful we need to be able to receive messages. This is</Comment><br/>
<Comment># achieved with the `receive` mechanism:</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The `receive do` block is used to listen for messages and process</Comment><br/>
<Comment># them when they are received. A `receive do` block will only</Comment><br/>
<Comment># process one received message. In order to process multiple</Comment><br/>
<Comment># messages, a function with a `receive do` block must recursively</Comment><br/>
<Comment># call itself to get into the `receive do` block again.</Comment><br/>
<Normal Text></Normal Text><br/>
<Definition>defmodule</Definition><Normal Text> </Normal Text><Module>Geometry</Module><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Definition>def</Definition><Normal Text> </Normal Text><Function>area_loop</Function><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>    </Normal Text><Keyword>receive</Keyword><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>      </Normal Text><Braces>{</Braces><Atom>:rectangle</Atom><Normal Text>, </Normal Text><Variable>w</Variable><Normal Text>, </Normal Text><Variable>h</Variable><Braces>}</Braces><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>        </Normal Text><Module>IO</Module><Normal Text>.</Normal Text><Function>puts</Function><Braces>(</Braces><String>"Area = </String><Interpolation>#{</Interpolation><Variable>w</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>h</Variable><Interpolation>}</Interpolation><String>"</String><Braces>)</Braces><br/>
<Normal Text>        </Normal Text><Function>area_loop</Function><Braces>()</Braces><br/>
<Normal Text>      </Normal Text><Braces>{</Braces><Atom>:circle</Atom><Normal Text>, </Normal Text><Variable>r</Variable><Braces>}</Braces><Normal Text> </Normal Text><Operator>-></Operator><br/>
<Normal Text>        </Normal Text><Module>IO</Module><Normal Text>.</Normal Text><Function>puts</Function><Braces>(</Braces><String>"Area = </String><Interpolation>#{</Interpolation><Float>3.14</Float><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>r</Variable><Normal Text> </Normal Text><Operator>*</Operator><Normal Text> </Normal Text><Variable>r</Variable><Interpolation>}</Interpolation><String>"</String><Braces>)</Braces><br/>
<Normal Text>        </Normal Text><Function>area_loop</Function><Braces>()</Braces><br/>
<Normal Text>    </Normal Text><Keyword>end</Keyword><br/>
<Normal Text>  </Normal Text><Keyword>end</Keyword><br/>
<Keyword>end</Keyword><br/>
<Variable></Variable><br/>
<Comment># Compile the module and create a process that evaluates `area_loop` in the shell</Comment><br/>
<Variable>pid</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Function>spawn</Function><Braces>(</Braces><Keyword>fn</Keyword><Normal Text> </Normal Text><Operator>-></Operator><Normal Text> </Normal Text><Module>Geometry</Module><Normal Text>.</Normal Text><Function>area_loop</Function><Braces>()</Braces><Normal Text> </Normal Text><Keyword>end</Keyword><Braces>)</Braces><Normal Text> </Normal Text><Comment>#=> #PID<0.40.0></Comment><br/>
<Comment># Alternatively</Comment><br/>
<Variable>pid</Variable><Normal Text> </Normal Text><Operator>=</Operator><Normal Text> </Normal Text><Function>spawn</Function><Braces>(</Braces><Module>Geometry</Module><Normal Text>, </Normal Text><Atom>:area_loop</Atom><Normal Text>, </Normal Text><Braces>[])</Braces><br/>
<Normal Text></Normal Text><br/>
<Comment># Send a message to `pid` that will match a pattern in the receive statement</Comment><br/>
<Variable>send</Variable><Normal Text> </Normal Text><Variable>pid</Variable><Normal Text>, </Normal Text><Braces>{</Braces><Atom>:rectangle</Atom><Normal Text>, </Normal Text><Integer>2</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Braces>}</Braces><br/>
<Comment>#=> Area = 6</Comment><br/>
<Comment>#   {:rectangle,2,3}</Comment><br/>
<Normal Text></Normal Text><br/>
<Variable>send</Variable><Normal Text> </Normal Text><Variable>pid</Variable><Normal Text>, </Normal Text><Braces>{</Braces><Atom>:circle</Atom><Normal Text>, </Normal Text><Integer>2</Integer><Braces>}</Braces><br/>
<Comment>#=> Area = 12.56000000000000049738</Comment><br/>
<Comment>#   {:circle,2}</Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># The shell is also a process, you can use `self` to get the current pid</Comment><br/>
<Function>self</Function><Braces>()</Braces><Normal Text> </Normal Text><Comment>#=> #PID<0.27.0></Comment><br/>
<Normal Text></Normal Text><br/>
<Comment># Code not found in the original, but needed to test the full range of the syntax</Comment><br/>
<Normal Text></Normal Text><br/>
<Definition>def</Definition><Normal Text> </Normal Text><Function>function</Function><Normal Text>, </Normal Text><Atom>do:</Atom><Normal Text> </Normal Text><Braces>{</Braces><Atom>:ok</Atom><Normal Text>, </Normal Text><Variable>result</Variable><Braces>}</Braces><br/>
<Normal Text></Normal Text><br/>
<Braces>[</Braces><br/>
<Normal Text>  </Normal Text><Atom>:a</Atom><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>:b</Atom><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>:c</Atom><br/>
<Braces>]</Braces><br/>
<Normal Text></Normal Text><br/>
<Braces>%{</Braces><br/>
<Normal Text>  </Normal Text><Atom>a:</Atom><Normal Text> </Normal Text><String>"a"</String><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>b:</Atom><Normal Text> </Normal Text><String>"b"</String><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>c:</Atom><Normal Text> </Normal Text><String>"c"</String><br/>
<Braces>}</Braces><br/>
<Normal Text></Normal Text><br/>
<Braces>%</Braces><Module>A</Module><Braces>{</Braces><br/>
<Normal Text>  </Normal Text><Atom>a:</Atom><Normal Text> </Normal Text><String>"a"</String><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>b:</Atom><Normal Text> </Normal Text><String>"b"</String><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>c:</Atom><Normal Text> </Normal Text><String>"c"</String><br/>
<Braces>}</Braces><br/>
<Normal Text></Normal Text><br/>
<Comment># Numerics</Comment><br/>
<Hex>0xBE_EF</Hex><br/>
<Octal>0o777_1</Octal><br/>
<Bin>0b1010_0101_01</Bin><br/>
<Integer>01234</Integer><br/>
<Integer>1234_5678_9</Integer><br/>
<Normal Text></Normal Text><br/>
<Float>3.14_159</Float><br/>
<Float>1_23.00_00</Float><br/>
<Float>4.13e20</Float><br/>
<Float>6.12e-8</Float><br/>
<Normal Text></Normal Text><br/>
<Normal Text></Normal Text><br/>
<String>"String Interpolation: </String><Interpolation>#{</Interpolation><Function>inspect</Function><Braces>(</Braces><Atom>nil</Atom><Braces>)</Braces><Interpolation>}</Interpolation><String>"</String><br/>
<Normal Text></Normal Text><br/>
<Comment># Sigils</Comment><br/>
<String>~r/</String><Special Char>\b</Special Char><String>foo_bar</String><Special Char>\b</Special Char><String>/g</String><br/>
<String>~s"asdf"</String><br/>
<String>~w[foo bar one two three]a</String><br/>
<String>~w(foo bar one two three)a</String><br/>
<Normal Text></Normal Text><br/>
<String>~c'char lists are typed like this now'</String><br/>
<Normal Text></Normal Text><br/>
<Comment># Documentation</Comment><br/>
<DocComment>@doc """</DocComment><br/>
<MarkdownHead>## Documentation</MarkdownHead><br/>
<DocComment>lorem ipsum dolor</DocComment><br/>
<DocComment></DocComment><br/>
<MarkdownMark>* </MarkdownMark><DocComment>a</DocComment><br/>
<MarkdownMark>* </MarkdownMark><DocComment>b</DocComment><br/>
<MarkdownMark>* </MarkdownMark><DocComment>c</DocComment><br/>
<DocComment></DocComment><br/>
<MarkdownMark>1. </MarkdownMark><DocComment>x</DocComment><br/>
<MarkdownMark>2. </MarkdownMark><DocComment>y</DocComment><br/>
<MarkdownMark>3. </MarkdownMark><DocComment>z</DocComment><br/>
<DocComment>"""</DocComment><br/>
<Normal Text></Normal Text><br/>
<Comment># Module Attributes</Comment><br/>
<Normal Text>@</Normal Text><Built In>compile</Built In><Normal Text> </Normal Text><Braces>{</Braces><Atom>:inline</Atom><Normal Text>, </Normal Text><Atom>foo:</Atom><Normal Text> </Normal Text><Integer>1</Integer><Braces>}</Braces><br/>
<Normal Text>@custom_attribute </Normal Text><Braces>[</Braces><Integer>1</Integer><Normal Text>, </Normal Text><Integer>2</Integer><Normal Text>, </Normal Text><Integer>3</Integer><Normal Text>, </Normal Text><Integer>4</Integer><Braces>]</Braces><br/>
<Normal Text></Normal Text><br/>
<Comment># More Atoms</Comment><br/>
<Atom>:"@foo"</Atom><br/>
<Atom>:bar?</Atom><br/>
<Atom>:bar!</Atom><br/>
<Braces>%{</Braces><br/>
<Normal Text>  </Normal Text><Atom>foo?:</Atom><Normal Text> </Normal Text><Atom>false</Atom><Normal Text>,</Normal Text><br/>
<Normal Text>  </Normal Text><Atom>"@bar":</Atom><Normal Text> </Normal Text><Integer>1</Integer><br/>
<Braces>}</Braces><br/>
<Atom>:+</Atom><br/>
<Atom>:**</Atom><br/>
<Atom>:++</Atom><br/>
<Atom>:%{}</Atom><br/>
<Normal Text></Normal Text><br/>
<Comment># Interpolation in Atoms</Comment><br/>
<Atom>:"bar</Atom><Interpolation>#{</Interpolation><Function>inspect</Function><Braces>(</Braces><Function>foo</Function><Braces>())</Braces><Interpolation>}</Interpolation><Atom>"</Atom><br/>
<Normal Text></Normal Text><br/>
<Comment># Character Literals</Comment><br/>
<Braces>[</Braces><Char Literal>?a</Char Literal><Normal Text>, </Normal Text><Char Literal>?b</Char Literal><Normal Text>, </Normal Text><Char Literal>?c</Char Literal><Normal Text>, </Normal Text><Char Literal>?z</Char Literal><Normal Text>, </Normal Text><Char Literal>?1</Char Literal><Normal Text>, </Normal Text><Char Literal>?-</Char Literal><Normal Text>, </Normal Text><Char Literal>?+</Char Literal><Normal Text>, </Normal Text><Char Literal>?.</Char Literal><Normal Text>, </Normal Text><Char Literal>?\s</Char Literal><Normal Text>, </Normal Text><Char Literal>?\n</Char Literal><Braces>]</Braces><br/>
<Normal Text></Normal Text><br/>
<Comment># Special Forms</Comment><br/>
<Definition>def</Definition><Normal Text> </Normal Text><Function>foo</Function><Braces>(</Braces><Variable Underscore>_</Variable Underscore><Normal Text>, </Normal Text><Variable Underscore>_opts</Variable Underscore><Braces>)</Braces><Normal Text> </Normal Text><Keyword>do</Keyword><br/>
<Normal Text>  </Normal Text><Module>IO</Module><Normal Text>.</Normal Text><Function>inspect</Function><Braces>(</Braces><Built In>__MODULE__</Built In><Braces>)</Braces><br/>
<Normal Text>  </Normal Text><Braces>%</Braces><Built In>__MODULE__</Built In><Braces>{}</Braces><br/>
<Keyword>end</Keyword><br/>
