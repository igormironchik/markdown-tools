const std = @import("std");

/// This is a doc comment
// This is a comment
fn getData() !u32 <beginfold id='1'>{</beginfold id='1'>
    return 666;
<endfold id='1'>}</endfold id='1'>

// multiline string
const hello_world_in_c =
    \\#include <stdio.h>
    \\
    \\int main(int argc, char **argv) {
    \\    printf("hello world\n");
    \\    return 0;
    \\}
;

// Top-level declarations are order-independent:
const print = @import("std").debug.print;

pub fn main() !void <beginfold id='1'>{</beginfold id='1'>
    inline for (values) |v, i| <beginfold id='1'>{</beginfold id='1'>
        if (i != 2) continue;
        try expect(v);
    <endfold id='1'>}</endfold id='1'>

    // error union
    var number_or_error: anyerror!i32 = error.ArgNotFound;

    print("\nerror union 2\ntype: {}\nvalue: {!}\n", .<beginfold id='1'>{</beginfold id='1'>
        @TypeOf(number_or_error), number_or_error,
    <endfold id='1'>}</endfold id='1'>);

    const stdout = std.io.getStdOut().writer();
    try stdout.print("Hello, {s}!\n", .<beginfold id='1'>{</beginfold id='1'>"world"<endfold id='1'>}</endfold id='1'>);
    const bytes = "hello";
    print("{}\n", .<beginfold id='1'>{</beginfold id='1'>@TypeOf(bytes)<endfold id='1'>}</endfold id='1'>); // *const [5:0]u8
    print("{d}\n", .<beginfold id='1'>{</beginfold id='1'>bytes[5]<endfold id='1'>}</endfold id='1'>); // 0
    print("{}\n", .<beginfold id='1'>{</beginfold id='1'>'e' == '\x65'<endfold id='1'>}</endfold id='1'>); // true
    print("{d}\n", .<beginfold id='1'>{</beginfold id='1'>'\u{1f4a9}'<endfold id='1'>}</endfold id='1'>);                     // 128169
    print("{d}\n", .<beginfold id='1'>{</beginfold id='1'>'ðŸ’¯'<endfold id='1'>}</endfold id='1'>);                            // 128175
    print("{}\n", .<beginfold id='1'>{</beginfold id='1'>mem.eql(u8, "hello", "h\x65llo")<endfold id='1'>}</endfold id='1'>); // true
    print("0x{x}\n", .<beginfold id='1'>{</beginfold id='1'>"\xff"[0]<endfold id='1'>}</endfold id='1'>); // non-UTF-8 strings are possible with \xNN notation.
    print("{u}\n", .<beginfold id='1'>{</beginfold id='1'>'âš¡'<endfold id='1'>}</endfold id='1'>);

    _ = @import("introducing_zig_test.zig");
<endfold id='1'>}</endfold id='1'>

// Declare an enum.
const Type = enum <beginfold id='1'>{</beginfold id='1'>
    ok,
    not_ok,
<endfold id='1'>}</endfold id='1'>;

test "async skip test" <beginfold id='1'>{</beginfold id='1'>
    var frame = async func();
    const result = await frame;
    try std.testing.expect(result == 1);
<endfold id='1'>}</endfold id='1'>

fn func() i32 <beginfold id='1'>{</beginfold id='1'>
    suspend <beginfold id='1'>{</beginfold id='1'>
        resume @frame();
    <endfold id='1'>}</endfold id='1'>
    return 1;
<endfold id='1'>}</endfold id='1'>

pub extern "c" fn @"error"() void;
pub extern "c" fn @"fstat$INODE64"(fd: c.fd_t, buf: *c.Stat) c_int;

const Color = enum <beginfold id='1'>{</beginfold id='1'>
  red,
  @"really red",
<endfold id='1'>}</endfold id='1'>;
const color: Color = .@"really red";

var y: i32 = add(10, x);
const x: i32 = add(12, 34);

test "comptime vars" <beginfold id='1'>{</beginfold id='1'>
    var x: i32 = 1;
    comptime var y: i32 = 1;

    x += 1;
    y += 1;

    try expect(x == 2);
    try expect(y == 2);

    if (y != 2) <beginfold id='1'>{</beginfold id='1'>
        // This compile error never triggers because y is a comptime variable,
        // and so `y != 2` is a comptime value, and this if is statically evaluated.
        @compileError("wrong y value");
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

const decimal_int = 98222;
const hex_int = 0xff;
const another_hex_int = 0xFF;
const octal_int = 0o755;
const binary_int = 0b11110000;

// underscores may be placed between two digits as a visual separator
const one_billion = 1_000_000_000;
const binary_mask = 0b1_1111_1111;
const permissions = 0o7_5_5;
const big_address = 0xFF80_0000_0000_0000;

const floating_point = 123.0E+77;
const another_float = 123.0;
const yet_another = 123.0e+77;

const hex_floating_point = 0x103.70p-5;
const another_hex_float = 0x103.70;
const yet_another_hex_float = 0x103.70P-5;

// underscores may be placed between two digits as a visual separator
const lightspeed = 299_792_458.000_000;
const nanosecond = 0.000_000_001;
const more_hex = 0x1234_5678.9ABC_CDEFp-10;

const A = error<beginfold id='1'>{</beginfold id='1'>One<endfold id='1'>}</endfold id='1'>;
const B = error<beginfold id='1'>{</beginfold id='1'>Two<endfold id='1'>}</endfold id='1'>;
(A || B) == error<beginfold id='1'>{</beginfold id='1'>One, Two<endfold id='1'>}</endfold id='1'>

const x: u32 = 1234;
const ptr = &x;
ptr.* == 1234

// get the size of an array
comptime <beginfold id='1'>{</beginfold id='1'>
    assert(message.len == 5);
<endfold id='1'>}</endfold id='1'>

test "iterate over an array" <beginfold id='1'>{</beginfold id='1'>
    var sum: usize = 0;
    for (message) |byte| <beginfold id='1'>{</beginfold id='1'>
        sum += byte;
    <endfold id='1'>}</endfold id='1'>
    try expect(sum == 'h' + 'e' + 'l' * 2 + 'o');
<endfold id='1'>}</endfold id='1'>

// use compile-time code to initialize an array
var fancy_array = init: <beginfold id='1'>{</beginfold id='1'>
    var initial_value: [10]Point = undefined;
    for (initial_value) |*pt, i| <beginfold id='1'>{</beginfold id='1'>
        pt.* = Point<beginfold id='1'>{</beginfold id='1'>
            .x = @intCast(i32, i),
            .y = @intCast(i32, i) * 2,
        <endfold id='1'>}</endfold id='1'>;
    <endfold id='1'>}</endfold id='1'>
    break :init initial_value;
<endfold id='1'>}</endfold id='1'>;

test "switch on non-exhaustive enum" <beginfold id='1'>{</beginfold id='1'>
    try expect(result);
    const is_one = switch (number) <beginfold id='1'>{</beginfold id='1'>
        .one => true,
        else => false,
    <endfold id='1'>}</endfold id='1'>;
    try expect(is_one);

    const array_ptr = array[0..array.len];

    if (a != b) <beginfold id='1'>{</beginfold id='1'>
        try expect(true);
    <endfold id='1'>}</endfold id='1'> else if (a == 9) <beginfold id='1'>{</beginfold id='1'>
        unreachable;
    <endfold id='1'>}</endfold id='1'> else <beginfold id='1'>{</beginfold id='1'>
        unreachable;
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

fn deferErrorExample(is_error: bool) !void <beginfold id='1'>{</beginfold id='1'>
    print("\nstart of function\n", .<beginfold id='1'>{</beginfold id='1'><endfold id='1'>}</endfold id='1'>);

    // This will always be executed on exit
    defer <beginfold id='1'>{</beginfold id='1'>
        print("end of function\n", .<beginfold id='1'>{</beginfold id='1'><endfold id='1'>}</endfold id='1'>);
    <endfold id='1'>}</endfold id='1'>

    errdefer <beginfold id='1'>{</beginfold id='1'>
        print("encountered an error!\n", .<beginfold id='1'>{</beginfold id='1'><endfold id='1'>}</endfold id='1'>);
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

pub fn syscall3(number: usize, arg1: usize, arg2: usize, arg3: usize) usize <beginfold id='1'>{</beginfold id='1'>
    return asm volatile ("syscall"
        : [ret] "={rax}" (-> usize)
        : [number] "{rax}" (number),
          [arg1] "{rdi}" (arg1),
          [arg2] "{rsi}" (arg2),
          [arg3] "{rdx}" (arg3)
        : "rcx", "r11"
    );
<endfold id='1'>}</endfold id='1'>
