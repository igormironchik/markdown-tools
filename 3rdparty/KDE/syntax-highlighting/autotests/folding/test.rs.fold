// Comment NOTE
<beginfold id='1'>/*</beginfold id='1'> Comment FIXME ALERT
	<endfold id='1'>*/</endfold id='1'>

// Identifiers
hellóñαωΑΩµo!();
HellóñαωΑΩµ::Hello;
'hellóñαωΑΩµo

pub use self::PathParameters::*;
pub use symbol::<beginfold id='2'>{</beginfold id='2'>Ident, Symbol as Name<endfold id='2'>}</endfold id='2'>;
use serialize::<beginfold id='2'>{</beginfold id='2'>self, Encoder, Decoder<endfold id='2'>}</endfold id='2'>;
use std::u32;

<beginfold id='3'>#[</beginfold id='3'>derive(Clone, PartialEq, Eq, Hash, Copy)<endfold id='3'>]</endfold id='3'>

pub struct Lifetime <beginfold id='2'>{</beginfold id='2'>
	pub id: NodeId,
	pub span: Span,
	pub bounds: Vec<PathSegment>
<endfold id='2'>}</endfold id='2'>

impl fmt::Debug for Lifetime <beginfold id='2'>{</beginfold id='2'>
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result <beginfold id='2'>{</beginfold id='2'>
		write!(f, "lifetime({}: {})", self.id, pprust::lifetime_to_string(self))
	<endfold id='2'>}</endfold id='2'>
<endfold id='2'>}</endfold id='2'>
impl<'a> PartialEq<&'a str> for Path <beginfold id='2'>{</beginfold id='2'>
	fn eq(&self, string: &&'a str) -> bool <beginfold id='2'>{</beginfold id='2'>
		self.segments.len() == 1 && self.segments<beginfold id='4'>[</beginfold id='4'>0<endfold id='4'>]</endfold id='4'>.identifier.name == *string
	<endfold id='2'>}</endfold id='2'>
<endfold id='2'>}</endfold id='2'>

enum TraitBoundModifier <beginfold id='2'>{</beginfold id='2'>
	None,
	Maybe,
<endfold id='2'>}</endfold id='2'>

union tests <beginfold id='2'>{</beginfold id='2'>
	a: i128,
	b: isize,
<endfold id='2'>}</endfold id='2'>

// Self vs self
trait T <beginfold id='2'>{</beginfold id='2'>
    type Item;
    // `Self` will be whatever type that implements `T`.
    fn new() -> Self;
    // `Self::Item` will be the type alias in the implementation.
    fn f(&self) -> Self::Item;
<endfold id='2'>}</endfold id='2'>

// Raw identifiers
extern crate foo;
fn main() <beginfold id='2'>{</beginfold id='2'>
    foo::r#try();
<endfold id='2'>}</endfold id='2'>

<beginfold id='3'>#[</beginfold id='3'>valid types<endfold id='3'>]</endfold id='3'>
fn types() <beginfold id='2'>{</beginfold id='2'>
	let num = 333_3_;
	let num_u8: u8 = 333u8;
	let num_u16: u16 = 333u16;
	let num_u32: u32 = 333u32;
	let num_u64: u64 = 333u64;
	let num_u128: u128 = 333u128;
	let num_usize: usize = 333usize;
	let num_float: f32 = 333.45f32;

	let binary = 0b1_010;
	let octal = 0o21535;
	let hexadecimal = 0x73A2_F;

	let char1: char = 'a';
	let char2: char = '\n';
	let char3: char = '\u{123_AF}';

	let byte1: u8 = b'a';
	let byte2: u8 = b'\x13';

	let string: str = "hello \n \r \u{123_________fd_} \
						bye";
	let byte_string: str = b"hello \t \0 \u{123} \b bye";
	let raw_string1: str = r"hello \t \b";
	let raw_string2: str = r####"hello \n "### bye"########;
	let raw_string3: str = br####"hello \n"####;

    // Invalid

	let invalid_binary= 0b1_015;
	let invalid_octal = 0o64_92;
	let invalid_hexadecimal = 0x7_3AY;

    let invalid_char1: char = '\y';
	let invalid_char2: char = '\324';
	let invalid_char3: char = '%%';
	let invalid_char4: char = '\n\dfd';
	let invalid_char5: char = 'aaaaa';
	let open_char: char = '&&&;

	let invalid_byte1: u8 = b'ab';
	let invalid_byte2: u8 = b'\b';
	let invalid_byte2: u8 = b'\u{123}';

	let invalid_string: str = "hello \b \u{_123} \u{1234567} \  bye";
<endfold id='2'>}</endfold id='2'>

//ControlFlow-specific keywords
fn controlflow(y: Vec<usize>) -> usize <beginfold id='2'>{</beginfold id='2'>
    let mut x = 0;
    while x < 10 <beginfold id='2'>{</beginfold id='2'>
        if x > 5 <beginfold id='2'>{</beginfold id='2'>
            x = 1;
        <endfold id='2'>}</endfold id='2'>
        else <beginfold id='2'>{</beginfold id='2'>
            return 5
        <endfold id='2'>}</endfold id='2'>
    <endfold id='2'>}</endfold id='2'>
    loop <beginfold id='2'>{</beginfold id='2'>
        x+= 1;
        break;
    <endfold id='2'>}</endfold id='2'>
    for z in y <beginfold id='2'>{</beginfold id='2'>
        match z <beginfold id='2'>{</beginfold id='2'>
            1 => continue,
            _ => x = 2,
        <endfold id='2'>}</endfold id='2'>
    <endfold id='2'>}</endfold id='2'>
    x
<endfold id='2'>}</endfold id='2'>
