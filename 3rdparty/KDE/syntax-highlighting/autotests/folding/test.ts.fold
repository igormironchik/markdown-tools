/// <reference types="node" />

// TypeScript Test

class Student <beginfold id='1'>{</beginfold id='1'>
    fullName: string;
    constructor(public firstName: string, public middleInitial: string, public lastName: string) <beginfold id='1'>{</beginfold id='1'>
        this.fullName = firstName + " " + middleInitial + " " + lastName;
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

interface Person <beginfold id='1'>{</beginfold id='1'>
    firstName: string;
    lastName: string;
<endfold id='1'>}</endfold id='1'>

function greeter(person : Person) <beginfold id='1'>{</beginfold id='1'>
    return "Hello, " + person.firstName + " " + person.lastName;
<endfold id='1'>}</endfold id='1'>

let user = new Student("Jane", "M.", "User");

// Built-in
document.body.innerHTML = greeter(user); to
JSON.stringify()
console.log("Hello world");
const os = require('os');
Math.LOG10E;
Number.MAX_SAFE_INTEGER;
String.raw<beginfold id='2'>`</beginfold id='2'>raw text \.\n${}<endfold id='2'>`</endfold id='2'>

import http = require<beginfold id='3'>(</beginfold id='3'>"http"<endfold id='3'>)</endfold id='3'>;
import path = require<beginfold id='3'>(</beginfold id='3'>"path"<endfold id='3'>)</endfold id='3'>;
import URL = url.URL;
import <beginfold id='1'>{</beginfold id='1'> Readable, Writable <endfold id='1'>}</endfold id='1'> from "stream";
import <beginfold id='1'>{</beginfold id='1'> isBuffer, isString, isObject <endfold id='1'>}</endfold id='1'> from "util";

const port = 8_88_8;
const baseUrl = new URL(<beginfold id='4'>`</beginfold id='4'>http://localhost:${port}/<endfold id='4'>`</endfold id='4'>);
const rootDir = path.dirname(__dirname);

const defaultBrowser = os.platform() === "win32" ? "edge" : "chrome";
let browser: "edge" | "chrome" | "none" = defaultBrowser;
let grep: string | undefined;

interface FileBasedTestConfiguration <beginfold id='1'>{</beginfold id='1'>
    <beginfold id='5'>[</beginfold id='5'>setting: string<endfold id='5'>]</endfold id='5'>: string;
<endfold id='1'>}</endfold id='1'>

function swapCase(s: string): string <beginfold id='1'>{</beginfold id='1'>
    return s.replace(/\w/g, (ch) => <beginfold id='1'>{</beginfold id='1'>
        const up = ch.toUpperCase();
        return ch === up ? ch.toLowerCase() : up;
    <endfold id='1'>}</endfold id='1'>);
<endfold id='1'>}</endfold id='1'>

for (var i in pieces) <beginfold id='1'>{</beginfold id='1'>
    switch (true) <beginfold id='1'>{</beginfold id='1'>
        case /^\"?Accession\"?/.test(pieces<beginfold id='5'>[</beginfold id='5'>i<endfold id='5'>]</endfold id='5'>):
            numeration<beginfold id='5'>[</beginfold id='5'>0<endfold id='5'>]</endfold id='5'> = i;
            break;
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

const enum ResponseCode <beginfold id='1'>{</beginfold id='1'>
    Success = 200,
    BadRequest = 400
<endfold id='1'>}</endfold id='1'>

// Substitutions
export function isInOpenInterval(start: number, end: number) <beginfold id='1'>{</beginfold id='1'>
    return tersible(a => a > start && a < end, () => <beginfold id='4'>`</beginfold id='4'>(${start}...${end})<endfold id='4'>`</endfold id='4'>)
<endfold id='1'>}</endfold id='1'>
const bar = <beginfold id='4'>`</beginfold id='4'>${x} ${y}<endfold id='4'>`</endfold id='4'>;

// readonly
function f1(mt: <beginfold id='5'>[</beginfold id='5'>number, number<endfold id='5'>]</endfold id='5'>, rt: readonly <beginfold id='5'>[</beginfold id='5'>number, number<endfold id='5'>]</endfold id='5'>) <beginfold id='1'>{</beginfold id='1'>
<endfold id='1'>}</endfold id='1'>

function f2(ma: string<beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>, ra: readonly string<beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>, mt: <beginfold id='5'>[</beginfold id='5'>string, string<endfold id='5'>]</endfold id='5'>, rt: readonly <beginfold id='5'>[</beginfold id='5'>string, string<endfold id='5'>]</endfold id='5'>) <beginfold id='1'>{</beginfold id='1'>
<endfold id='1'>}</endfold id='1'>

type ReadWrite<T> = <beginfold id='1'>{</beginfold id='1'> -readonly <beginfold id='5'>[</beginfold id='5'>P in keyof T<endfold id='5'>]</endfold id='5'> : T<beginfold id='5'>[</beginfold id='5'>P<endfold id='5'>]</endfold id='5'> <endfold id='1'>}</endfold id='1'>;

// const assertion
let obj = <beginfold id='1'>{</beginfold id='1'> x: 10, y: <beginfold id='5'>[</beginfold id='5'>20, 30<endfold id='5'>]</endfold id='5'>, z: <beginfold id='1'>{</beginfold id='1'> a: <beginfold id='1'>{</beginfold id='1'> b: 42 <endfold id='1'>}</endfold id='1'> <endfold id='1'>}</endfold id='1'> <endfold id='1'>}</endfold id='1'> as const;
let r2 = <beginfold id='1'>{</beginfold id='1'> x: 20, y: 10 <endfold id='1'>}</endfold id='1'> as const;
let r2 = <beginfold id='1'>{</beginfold id='1'>...p<endfold id='1'>}</endfold id='1'> as const;
let p1 = <beginfold id='1'>{</beginfold id='1'> x: 10, y: 20 as const <endfold id='1'>}</endfold id='1'>;
let p2 = <beginfold id='1'>{</beginfold id='1'> 10 as const, 'foo' as const <endfold id='1'>}</endfold id='1'>;

// Definite assignment operator
class Cl <beginfold id='1'>{</beginfold id='1'>
    one?: string;
    two!: string;
<endfold id='1'>}</endfold id='1'>
let x! = 1;

// Function with multiple arguments
const children = <beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>.map<Set<Map<number, string>>>(element => <beginfold id='1'>{</beginfold id='1'>
    if (!this.identityProvider) <beginfold id='1'>{</beginfold id='1'>
        return element;
    <endfold id='1'>}</endfold id='1'>
    return element;
<endfold id='1'>}</endfold id='1'>);

// Numerics
var a = 0xA;
var b = 0b1;
var c = 0o7;
var d = 1.1E+3;
var e = 1.E+3;
var f = .1E+3;
var g = 1E+3;
var h = 1.1;
var i = 1.;
var j = .1;
var k =  1;
var l = 1_2.e+3_22 | .2e2 | 0o1_23 | 11.2 | 08;

// Bigint
const binBig = 0b101n;
const octBig = 0o567n;
const hexBig = 0xC0Bn;
const decBig = 123n;

// Invalid numbers
var l = 0xA1t;
var m = 0b0123;
var n = 0o29;
var n = 0_7;
var n = 1___1;
var n = 1__;
var n = 11__.;
var n = 1__.e+3_22;
var n = .2_e2;

// Types
let a: null = null;
let b: number = 123;
let c: number = 123.456;
let d: string = <beginfold id='4'>`</beginfold id='4'>Geeks<endfold id='4'>`</endfold id='4'>;
let e: undefined = undefined;
let f: boolean = true;
let g: number = 0b111001; // Binary
let h: number = 0o436; // Octal
let i: number = 0xadf0d; // Hexa-Decimal
let j: bigint = 123n;

const query = query<<beginfold id='5'>[</beginfold id='5'>number<endfold id='5'>]</endfold id='5'>, number>(<beginfold id='4'>`</beginfold id='4'>
        SELECT *
        FROM statistics
        WHERE unit_id = $1<endfold id='4'>`</endfold id='4'>)

function runQuery() <beginfold id='1'>{</beginfold id='1'>
    const query = createQuery<<beginfold id='5'>[</beginfold id='5'>number<beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'><endfold id='5'>]</endfold id='5'>, Table<Columns>>(<beginfold id='4'>`</beginfold id='4'>
        some SQL here
    <endfold id='4'>`</endfold id='4'>)
    return database.execute(query)
<endfold id='1'>}</endfold id='1'>

aa: <sdf/> string ?<ssd/> string
 string // Don't highlight
aa: string assa |
   string
   string ;
   string

aa: <beginfold id='1'>{</beginfold id='1'> string
    string <endfold id='1'>}</endfold id='1'> // Don't highlight

aa: <beginfold id='5'>[</beginfold id='5'> string
      string <endfold id='5'>]</endfold id='5'>
aa: ( string
      string ) // Don't highlight
aa: string <string>
interface a <beginfold id='1'>{</beginfold id='1'>
    aa: <beginfold id='6'>/*</beginfold id='6'> comment
        <endfold id='6'>*/</endfold id='6'> string,
    bb: <beginfold id='6'>/*</beginfold id='6'> comment <endfold id='6'>*/</endfold id='6'>
        number,
    cc: // comment
        void,
    dd:
        any,
<endfold id='1'>}</endfold id='1'>

null, <<beginfold id='1'>{</beginfold id='1'><beginfold id='5'>[</beginfold id='5'>key<endfold id='5'>]</endfold id='5'>: () => any<endfold id='1'>}</endfold id='1'>> null
null, <<beginfold id='1'>{</beginfold id='1'><beginfold id='5'>[</beginfold id='5'>key<endfold id='5'>]</endfold id='5'>: () =><beginfold id='1'>{</beginfold id='1'>a: number<endfold id='1'>}</endfold id='1'><endfold id='1'>}</endfold id='1'>> null

// Correctly highlighting regular expressions
dt = ((dt<beginfold id='5'>[</beginfold id='5'>0<endfold id='5'>]</endfold id='5'> * 1e9 + dt<beginfold id='5'>[</beginfold id='5'>1<endfold id='5'>]</endfold id='5'>) / 1e6).toFixed(3).replace(/\.?0+$/, '') + 'ms';
(a<beginfold id='5'>[</beginfold id='5'>0<endfold id='5'>]</endfold id='5'> / 2) / (2)

// Type guards
function isNumber(x: any): x is number <beginfold id='1'>{</beginfold id='1'>
    return typeof x === "number";
<endfold id='1'>}</endfold id='1'>

// Conditional expressions (highlight keywords before ":")
class C <beginfold id='1'>{</beginfold id='1'>
    w = () =>
        this.a() ? true : this.b() ? false : true;
    z = () =>
        this.b() ? hello : k;
<endfold id='1'>}</endfold id='1'>

function foo<T extends X>(arg: T): T extends B ? number : string <beginfold id='1'>{</beginfold id='1'>
  if (arg === "A") return <T extends B ? number : never>111;
  return <T extends B ? never : string>"returning a string";
<endfold id='1'>}</endfold id='1'>

let x = (foo === null || foo === undefined) ?
    undefined :
    foo.bar.baz();
let y = (foo === null || foo === undefined) ? <beginfold id='6'>/*</beginfold id='6'> comment <endfold id='6'>*/</endfold id='6'> undefined :
    foo.bar.baz();

// Operator ??
let x = foo ?? bar();

// Types and logical `&&` and `||` operators after `as` expression
Date as any || null;

//Assertions
const assert: (value: unknown) => asserts value = value => <beginfold id='1'>{</beginfold id='1'><endfold id='1'>}</endfold id='1'>
declare function assertIsString(value: unknown): asserts value is string;
declare function assertIsArrayOfStrings(value: unknown): asserts value is string<beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>;
declare function assertDefined<T>(value: T): asserts value is NonNullable<T>;
namespace Debug <beginfold id='1'>{</beginfold id='1'>
    export declare function assert(value: unknown, message?: string): asserts value;
    export declare function assertDefined<T>(value: T): asserts value is NonNullable<T>;
<endfold id='1'>}</endfold id='1'>

// Only highlight valid regular expressions, of a single line, after strings
// See: https://github.com/microsoft/TypeScript-TmLanguage/issues/786
"text" /No-Regex
"text" /Regex[:)]*/;
const a = "6" / 2; <beginfold id='6'>/*</beginfold id='6'>comment<endfold id='6'>*/</endfold id='6'> const b = 5;
console.log("4" / "2"); // 2
// Single quote
const a = '6' / 2; <beginfold id='6'>/*</beginfold id='6'>comment<endfold id='6'>*/</endfold id='6'> const b = 5;
console.log('4' / '2'); // 2
// Template
const a = <beginfold id='4'>`</beginfold id='4'>6<endfold id='4'>`</endfold id='4'> / 2; <beginfold id='6'>/*</beginfold id='6'>comment<endfold id='6'>*/</endfold id='6'> const b = 5;
console.log(<beginfold id='4'>`</beginfold id='4'>4<endfold id='4'>`</endfold id='4'> / <beginfold id='4'>`</beginfold id='4'>2<endfold id='4'>`</endfold id='4'>); // 2

 <beginfold id='5'>[</beginfold id='5'>1, 2, 3<endfold id='5'>]</endfold id='5'>.reduce<readonly number<beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>>((previous) => previous, <beginfold id='5'>[</beginfold id='5'><endfold id='5'>]</endfold id='5'>);

// Multiline arrow assignment
const h = <beginfold id='1'>{</beginfold id='1'>
  setSubProperty: <
      T extends A,
      K extends keyof T,
      J extends keyof T<beginfold id='5'>[</beginfold id='5'>K<endfold id='5'>]</endfold id='5'>
    >(
      property: K,
      key: J,
      value: T<beginfold id='5'>[</beginfold id='5'>K<endfold id='5'>]</endfold id='5'><beginfold id='5'>[</beginfold id='5'>J<endfold id='5'>]</endfold id='5'>
    ) =>  <beginfold id='1'>{</beginfold id='1'><endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>

// Private-Named Instance Fields
class Greeter <beginfold id='1'>{</beginfold id='1'>
    #name: string;
    constructor(name: string) <beginfold id='1'>{</beginfold id='1'>
        this.#name = name;
    <endfold id='1'>}</endfold id='1'>
    greet() <beginfold id='1'>{</beginfold id='1'>
        console.log(<beginfold id='4'>`</beginfold id='4'>hello ${this.#name}<endfold id='4'>`</endfold id='4'>);
    <endfold id='1'>}</endfold id='1'>
<endfold id='1'>}</endfold id='1'>
class Test <beginfold id='1'>{</beginfold id='1'>
    #NAME1: () => string;
    prop1 = x.#NAMEabc.#NAMEabc;
    prop2 = x.#NAMEabc.#NAMEabc();
    prop3 = this.#NAMEabc.#NAME();
<endfold id='1'>}</endfold id='1'>

// Type-only imports and exports
import type T from "mod";
import type <beginfold id='1'>{</beginfold id='1'> U, V <endfold id='1'>}</endfold id='1'> from "mod";
import type * as types from "mod";
import type from "mod";
import type = require<beginfold id='3'>(</beginfold id='3'>"mod"<endfold id='3'>)</endfold id='3'>;
import type T = require<beginfold id='3'>(</beginfold id='3'>"mod"<endfold id='3'>)</endfold id='3'>;

export <beginfold id='1'>{</beginfold id='1'> a as b, x <endfold id='1'>}</endfold id='1'>;
export * from "AnotherModule";
export <beginfold id='1'>{</beginfold id='1'> k as m, l <endfold id='1'>}</endfold id='1'> from "AnotherModule";
export type <beginfold id='1'>{</beginfold id='1'> T <endfold id='1'>}</endfold id='1'>;
export type <beginfold id='1'>{</beginfold id='1'> U <endfold id='1'>}</endfold id='1'> from "AnotherModule";

// 'awaited' type operator: https://github.com/microsoft/TypeScript/pull/35998
let v1: awaited number;
let v2: awaited Promise<number>;
function f7<U>() <beginfold id='1'>{</beginfold id='1'>
    let v0: awaited U;
    let v1: awaited Promise<U>;
<endfold id='1'>}</endfold id='1'>

// Tagged template literals
tagFunc<beginfold id='4'>`</beginfold id='4'>
    Hello world!
    ${ alert("Hello!"); }<endfold id='4'>`</endfold id='4'>;
obj.something.tagFunc<beginfold id='4'>`</beginfold id='4'>Setting ${setting} is ${value + 5}!<endfold id='4'>`</endfold id='4'>;
