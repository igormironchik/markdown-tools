@0xdbb9ad1f14bf0b36;  # unique file ID, generated by `capnp id`
struct Foo @0x8db435604d0d3723 { }

struct Person {
  name @0 :Text;
  birthdate @3 :Date;
  phones @2 :List(PhoneNumber);

  struct PhoneNumber {
    type @1 :Type;

    enum Type {
      mobile @0;
      home @1;
      work @2;
    }
  }
}

struct Dummy {
  byName @0 :Map(Text, Person);

  foo @0 :Int32 = 123;
  bar @1 :Text = "blah";
  baz @2 :List(Bool) = [ true, false, false, true ];
  qux @3 :Person = (name = "Bob", email = "bob@example.com");
  corge @4 :Void = void;
  grault @5 :Data = 0x"a1 40 33";

  union {
    circle @1 :Float64 = nan;      # radius
    square @2 :Float64 = 12.23e+2; # width
  }

  address :group {
    # Note:  This is a terrible way to use groups, and meant
    #        only to demonstrate the syntax.
    houseNumber @8 :UInt32 = 01238;
    city @10 :Text = "abc\ndef\p\xax\xabc";
  }
}

const pi :Float32 = 3.14159;
const foo :Int32 = 0x123;
const bar :SomeStruct = (id = .foo, message = .bar);

interface Directory extends(Node) {
  list @0 () -> (list :List(Entry));
  create @1 (name :Text) -> (file :File);
  delete @4 (name :Text);
  link @5 (name :Text, node :Node);
  read @1 (startAt :UInt64 = 0, amount :UInt64 = 0xffffffffffffffff)
       -> (data :Data);
}

interface Assignable(T) {
  # A generic interface, with non-generic methods.
  get @0 () -> (value :T);
  set @1 (value :T) -> ();
}

interface AssignableFactory {
  newAssignable @0 [T] (initialValue :T)
      -> (assignable :Assignable(T));
  # A generic method.
}

newUnsetAssignable @1 [T] () -> (assignable :Assignable(T));
getNamedAssignable @2 (name :Text) -> (assignable :Assignable);

struct Baz {
  bar @0 :Foo.Bar;

  using Foo.Bar;
  bar @0 :Bar;

  using T = Foo.Bar;
  bar @0 :T;

  baz @0 :import "bar.capnp".Baz;
  # Use type "Baz" defined in bar.capnp.
}

using Bar = import "bar.capnp";
using import "bar.capnp".Baz;

annotation foo(struct, enum) :Text;
# Declare an annotation 'foo' which applies to struct and enum types.

struct MyType $foo("bar") {
  # ...
}

annotation baz(*) :Int32;
annotation myAnnotation(struct) :Int32 $baz(10);

$baz(1);  # Annotate the file.

struct MyStruct $baz(2) {
  myField @0 :Text = "default" $baz(3);
  number @1 :Int32 $qux;
  myUnion :union $baz(4) {
    # ...
  }
}

interface MyInterface $baz(7) {
  myMethod @0 (myParam :Text $baz(9)) -> () $baz(8);
}

const myConst :Int32 = 123 $baz(11);

$corge(string = "hello", number = 123);
$grault();  # value defaults to 123
